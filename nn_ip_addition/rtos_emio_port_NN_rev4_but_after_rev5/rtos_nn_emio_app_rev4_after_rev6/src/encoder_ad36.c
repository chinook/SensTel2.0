/*
 * encoder_ad36.c
 *
 *  Created on: Mar 24, 2018
 *      Author: Jerome Pare-Lepine
 *      Notes:
 *          !!ATTN!! readPos() is now set to read the same pins for both 12 and 22 bit
 *          encoders - the 22 bit one got damaged by the wind turbine and we replaced it
 *          with the 12 bits one. Lookout for this if you want to use both circuits
 *          again.
 *      	1. The AD36 is an absolute encoder that uses SSI to output its data.
 *      	2. The code below reads the SSI data by bitbanging two IO lines. Using an
 *      	SPI peripheral with interrupts instead would be far more efficient. If no
 *      	SPI peripheral is available, bitbanging both interfaces at the same time
 *      	would still drop the execution time by half.
 *      	3.	Non-ultrascale Zynq SoCs have 4 I/O banks; 0&1 are MIO and 2&3 are EMIO.
 *  		In the case of the z7007s part (like on the MiniZed devboard), the MIO
 *  		bank pin numbers range from [53:0] while the EMIO pins range from [MAX:54].
 *  		Knowing this, the developer can use the EMIO pins defined in Vivado
 *  		using the "xgpiops" driver. Two IO function sets are available in the driver:
 *  		One to use the pins atomically (work with only one IO at a time) -
 *  		ie: XGpioPs_SetDirectionPin
 *  		and one to use the whole bank (work with masks to manipulate all of the IOs) -
 *  		ie: XGpioPs_SetDirection.
 *  		In atomical functions' arguments, use the pin numbers directly, ex: 54.
 *  		In bank functions, start with bank 2.
 *  		4. The actual bitbang code (readPos()) is taken from Posital SSI
 *  		documentation.
 *
 */

//==============================================================================
// INCLUDES
//==============================================================================
#include "encoder_ad36.h"


//==============================================================================
// DEFINITIONS
//==============================================================================
#define EMIO_GPIO_BaseAddress	XPAR_PS7_GPIO_0_BASEADDR
#define SSI_22BITS_RES			22
#define SSI_12BITS_RES			12
#define IDLE_CLK_POL			1	/* The sensor's clock line is idle high */


//==============================================================================
// FUNCTION DEFINITIONS
//==============================================================================
u32 initSSIpins(XGpioPs* bankPins)
/*
* \brief       Initialize the EMIO pins struct instance using the autogenerated
*              bsp config.
*              Initialize the directions and levels of the pins used to read position
*              data from the encoders.
*
* \param[in]   bankPins         - Pointer to the EMIO Gpio peripheral struct
*                                 instance to be initialized.
*/
{
	s32 status = 0;
	u32 bankDir,
		bankOpStatus;
	XGpioPs_Config bankConf;

	status = XGpioPs_CfgInitialize(bankPins, &bankConf, EMIO_GPIO_BaseAddress);
	if (status != XST_SUCCESS) {
		xil_printf("Gpio Initialization Failed\r\n");
		return XST_FAILURE;
	}

	/* Pins 0 and 2 of the 4 bits EMIO vector are the SSI clock outputs.
	 *  **Double check the pins with the hardware system */
	bankDir = XGpioPs_GetDirection(bankPins, 0x2U); /* For debug purposes */
	XGpioPs_SetDirection(bankPins, 0x2U, 0x00000025U);
	bankDir = XGpioPs_GetDirection(bankPins, 0x2U); /* For debug purposes */

	/* Pins 0 and 2 of the 4 bits EMIO vector are to be the enabled SSI clock
	 *  outputs.
	bankOpStatus = XGpioPs_GetOutputEnable(bankPins, 0x2U); /* For debug purposes */
	XGpioPs_SetOutputEnable(bankPins, 0x2U, 0x00000025U);
	bankOpStatus = XGpioPs_GetOutputEnable(bankPins, 0x2U); /* For debug purposes */

	/* Mimic a idle high SSI clock pin, for Pitch */
	XGpioPs_WritePin(bankPins, SSI_BB_PITCH_CLK, IDLE_CLK_POL);
	/*
	 * TODO: Mimic a idle high SSI clock pin, for Gear
	 */

	return XST_SUCCESS;
}


u32 readPos(XGpioPs* bankPins, eEncResolution_t res)
/*
* \brief       Reads SSI data from a single encoder by bitbanging 2 IOs;
*              One is used to toggle the CLOCK line and the other is used to read
*              the logic levels (updated after a CLOCK line level transition) on
*              the incoming DATA line.
*
* \param[in]   bankPins         - Pointer to the EMIO Gpio peripheral struct instance.
* \param[in]   res              - Resolution of the encoder to read. Also selects the hardware
*                                 interface (the clock and data pins used to do the bitbanging).
*
*/
{
	static u32 bit_count = 0, clk_pin = 0, dat_pin = 0, Res = 0;
	static u32 result = 0;
	static u32 readPin = 0;
	static u32 dly = 0;
	u8 criss = 0;
	result = 0;

	/* Select the IO bitbang interface and iteration quantity */
	switch(res)
	{
		case TwelveBits:
			 Res = SSI_12BITS_RES;
			 /* Gear encoder is now used for pitch
			 clk_pin = SSI_BB_GEAR_CLK;
			 dat_pin = SSI_BB_GEAR_DAT; */
			 clk_pin = SSI_BB_PITCH_CLK;
			 dat_pin = SSI_BB_PITCH_DAT;
			 break;

		case TwentyTwoBits:
			Res = SSI_22BITS_RES;
			clk_pin = SSI_BB_PITCH_CLK;
			dat_pin = SSI_BB_PITCH_DAT;
			break;

	}

	/* Do the actually bitbanging */
	for (bit_count=0; bit_count <= Res; bit_count++)
	{
		/* Falling edge on clock port */
		XGpioPs_WritePin(bankPins, clk_pin, !IDLE_CLK_POL);

		/* Left-shift the current result */
		result = (result << 1);

		for(dly = 0; dly < READ_DLY; dly++){
			criss ^= 1;
		}

		/* Read the port data */
		readPin = XGpioPs_ReadPin(bankPins, dat_pin);

		/* Rising edge on clock port, data changes */
		XGpioPs_WritePin(bankPins, clk_pin, IDLE_CLK_POL);

		for(dly = 0; dly<READ_DLY; dly++){
			criss ^= 1;
		}

		/* Evaluate the port data (port set or clear) */
		if ( readPin != 0)
		{
			/* Bit is set, set LSB of result */
			result = result | 1;
		}
	}
	return result;
}
