/*
 * can.c
 *
 *  Created on: May 25, 2018
 *      Author: Jerome Pare-Lepine
 */

//==============================================================================
// INCLUDES
//==============================================================================
#include "can.h"
#include "xcanps.h"
#include "xcanps_hw.h"
#include "interrupts.h"
#include "xstatus.h"
#include "ChinookCanUtils.h"


//==============================================================================
// FUNCTION DEFINITIONS
//==============================================================================
void SendFrame(XCanPs *InstancePtr, CanMsgSid_t DestSid, CanMsgData_t *Payload)
/*
* \brief       Send a CAN frame.
*
* \param[in]   InstancePtr           - Pointer to the CAN peripheral instance - for driver calls.
* \param[in]   DestSid               - Destination SID.
* \param[in]   Payload               - Pointer to the data to be transmitted.
*
*/
{
	u8 *FramePtr;

	/*
	 * Create correct values for Identifier and Data Length Code Register.
	 */
	TxFrame[0] = (u32)XCanPs_CreateIdValue(DestSid, 0, 0, 0, 0);
	TxFrame[1] = (u32)XCanPs_CreateDlcValue(FRAME_DATA_LENGTH);

	FramePtr = (u8 *)(&TxFrame[2]);
	memcpy((void *)FramePtr, (void *)Payload, 4);

	/*
	 * Now wait until the TX FIFO is not full and send the frame.
	 */
	while (XCanPs_IsTxFifoFull(InstancePtr) == TRUE);
	XCanPs_Send(InstancePtr, TxFrame);
}

s32 InitCan(XCanPs *InstancePtr, u32 DevId)
/*
* \brief       Initialize a peripheral struct instance using the autogenerated bsp config.
*
* \param[in]   InstancePtr         - Pointer to the CAN peripheral struct instance to be
*                                    initialized.
* \param[in]   DevId               - Memory-mapped address of the peripheral to init
*/
{
	s32 Status;
	XCanPs_Config *ConfigPtr;

	ConfigPtr = XCanPs_LookupConfig(DevId);
	if (ConfigPtr == NULL) {
		return XST_FAILURE;
	}
	Status = XCanPs_CfgInitialize(InstancePtr,
				ConfigPtr,
				ConfigPtr->BaseAddr);

	XCanPs_EnterMode(InstancePtr, XCANPS_MODE_CONFIG);
	while(XCanPs_GetMode(InstancePtr) != XCANPS_MODE_CONFIG);

	XCanPs_SetBaudRatePrescaler(InstancePtr, TEST_BRPR_BAUD_PRESCALAR);
	XCanPs_SetBitTiming(InstancePtr, TEST_BTR_SYNCJUMPWIDTH,
					TEST_BTR_SECOND_TIMESEGMENT,
					TEST_BTR_FIRST_TIMESEGMENT);

	return Status;
}

void InitCanInterrupts(XCanPs *InstancePtr, u16 DevIntId)
/*
* \brief       Registers the peripheral's interrupt handlers to its peripheral
*              instance struct. Also lists it to be registered to the Interrupt
*              Controller.
*
* \param[in]   InstancePtr    - Pointer to the XTmrCtr peripheral struct
*                               instance for which the interrupts are to be setup.
* \param[in]   DevIntId       - ID of the peripheral in the Interrupt Controller's
*                               vector
*/
{

	XCanPs_SetHandler(InstancePtr, XCANPS_HANDLER_SEND,
			(void *)CANSendHandler, (void *)InstancePtr);
	XCanPs_SetHandler(InstancePtr, XCANPS_HANDLER_RECV,
			(void *)CANRecvHandler, (void *)InstancePtr);
	XCanPs_SetHandler(InstancePtr, XCANPS_HANDLER_ERROR,
			(void *)CANErrorHandler, (void *)InstancePtr);
	XCanPs_SetHandler(InstancePtr, XCANPS_HANDLER_EVENT,
			(void *)CANEventHandler, (void *)InstancePtr);

	AddHandler2InitTable(InstancePtr, DevIntId, (Xil_InterruptHandler) XCanPs_IntrHandler, (void *)&ExceptionHandlers);

}

void StartCanInterrupts(XCanPs *InstancePtr)
/*
* \brief       Leave the config mode and start acknowledging the interrupts
*
* \param[in]   InstancePtr         - Pointer to the CAN peripheral struct
*/
{
	XCanPs_IntrEnable(InstancePtr, XCANPS_IXR_ALL);
	XCanPs_EnterMode(InstancePtr, XCANPS_MODE_NORMAL);
	while(XCanPs_GetMode(InstancePtr) != XCANPS_MODE_NORMAL);
}
