/*
 * i2c.c
 *
 *  Created on: Apr 7, 2018
 *      Author: Jerome Pare-Lepine
 *      Notes: Glue layer between driver code and the Xilinx I2C firmware.
 *      The implementation uses polling - not the best since the driver
 *      is used for ADC data acquisition which is called periodically and
 *      potentially very often. Improving this would lower ADC read latencies
 *      but switching it to use interrupts would also require additional code
 *      overhead.
 *      Ported and modded from Avnet's Minized MAX44000 I2C example.
 *      Get it at: http://zedboard.org/support/design/18891/146
 *
 */

//==============================================================================
// INCLUDES
//==============================================================================
#include "i2c.h"


int I2C_write(XIicPs *i2cinst, u32 ZynqIicAddress, u8 slave_address,	\
				u8 register_offset, u8 byte_count, u8 *write_values)
/*
* \brief       Use the Zynq IIC Controller to write a value to a register at
*              a given offset. Byte count added so that the user can write to registers
*              of various sizes.
*
* \param[in]   i2cinst           - Pointer to the i2c peripheral instance - for driver calls.
* \param[in]   ZynqIicAddress    - Not used anymore. You could remove it.
* \param[in]   slave_address     - address of the slave peripheral to write to
* \param[in]   register_offset   - offset of register to write to
* \param[in]   byte_count        - quantity of bytes to write (excludes addresses and offsets)
* \param[in]   write_value       - pointer to the array containing the actual write values
*
* \return      XST_SUCCESS if operation succeeded
* 			   XST_INVALID_PARAM if the byte count param is larger than the TxBuffer size
*/
{
	int Status = XST_SUCCESS;

	if(byte_count > TX_BUFFER_SZ - 1){
		Status = XST_INVALID_PARAM;
		return Status;
	}

	/* Create the buffer to be just large enough to hold the data to be sent */
	u8 TxBuffer[TX_BUFFER_SZ];

	/* First add the offset of the register to write */
	TxBuffer[0] = register_offset;

	/* Append all the write values. This */
	for(int i = 0; i < byte_count; i++){
		TxBuffer[i + 1] = write_values[i];
	}

	/* Use the Xilinx driver to interact with the peripheral. 3 is the */
	Status = XIicPs_MasterSendPolled(i2cinst, TxBuffer, 3, slave_address);
	if (Status != XST_SUCCESS) return XST_FAILURE;
	//Wait until bus is idle to start another transfer.
	while (XIicPs_BusIsBusy(i2cinst)) {/* NOP */}

	return(Status);
}

int I2C_read(XIicPs *i2cinst, u32 ZynqIicAddress, u8 slave_address,    \
		u8 register_offset, u8 *read_value)
/*
* \brief       Use the Zynq IIC Controller to read a value from a
*              slave register at a given offset. Could use a good cleanup
*              as many artifacts from the example remains.
*
* \param[in]   i2cinst           - Pointer to the i2c peripheral instance - for driver calls.
* \param[in]   ZynqIicAddress    - Not used anymore. You could remove it.
* \param[in]   slave_address     - address of the slave peripheral to read from
* \param[in]   register_offset   - offset of register
* \param[in]   *read_value       - pointer to the array where read values are to be stored
*
* \return      XST_SUCCESS if operation succeeded
*/
{
	int Status = XST_SUCCESS, i;
	u8 TxBuffer[3]; /* Could be made of size 1 */
	u8 RxBuffer[2];	/* Unused, can be removed */

	TxBuffer[0] = register_offset;
	Status = XIicPs_MasterSendPolled(i2cinst, TxBuffer, 1, slave_address);
	if (Status != XST_SUCCESS) return XST_FAILURE;
	//Wait until bus is idle to start another transfer.
	while (XIicPs_BusIsBusy(i2cinst)) {/* NOP */}

	/* Get the data payload */
	Status = XIicPs_MasterRecvPolled(i2cinst, read_value, 2, slave_address);
	if (Status != XST_SUCCESS)
		return XST_FAILURE;

	if(Status==XST_SUCCESS)	/* Unused, can be removed */

	/* Inefficient delay that was used to prevent peripheral faults
	 * during repeated requests. Could be replaced by a call to
	 * XIicPs_BusIsBusy() or, better, removal. */
	for(i = 0; i < 100000; i++){};

	return(Status);
}

void InitI2CPeripherals(XIicPs *i2cinst, u32 Baseaddress)
/*
* \brief       Initialize a i2c struct instance using the autogenerated bsp config
*              and the specified frequency.
*
* \param[in]   i2cinst           - Pointer to the i2c peripheral struct instance to be
*                                  initialized.
* \param[in]   Baseaddress       - Memory-mapped address of the peripheral to init
*/
{
	XIicPs_Config *Config;

	Config = XIicPs_LookupConfig(Baseaddress);
	XIicPs_CfgInitialize(i2cinst, Config, Config->BaseAddress);
	XIicPs_SetSClk(i2cinst, I2C_SPEED);
}
